
# This file was autogenerated do not Edit !!!!!!
# instead import and subclass the Device class 

from pydevmgr_elt.base import EltDevice
from pydevmgr_core import Defaults as RD
from pydevmgr_core import NodeVar
from typing import Any 

N = EltDevice.Node

CN = EltDevice.Node.Config
CI = EltDevice.Interface.Config
CR = EltDevice.Rpc.Config


class MotorCfgConfig(EltDevice.Cfg.Config):
    active_low_index: RD[CN] = CN(suffix='cfg.bArrActiveLow[3].bValue' )
    active_low_lhw: RD[CN] = CN(suffix='cfg.bArrActiveLow[1].bValue' )
    active_low_lstop: RD[CN] = CN(suffix='cfg.bArrActiveLow[0].bValue' )
    active_low_ref: RD[CN] = CN(suffix='cfg.bArrActiveLow[2].bValue' )
    active_low_uhw: RD[CN] = CN(suffix='cfg.bArrActiveLow[4].bValue' )
    active_low_ustop: RD[CN] = CN(suffix='cfg.bArrActiveLow[5].bValue' )
    axis_type: RD[CN] = CN(suffix='cfg.nAxisType', parser='AxisType')
    backlash: RD[CN] = CN(suffix='cfg.lrBacklash' )
    brake: RD[CN] = CN(suffix='cfg.bUseBrake' )
    check_inpos: RD[CN] = CN(suffix='cfg.bCheckInPos' )
    disable: RD[CN] = CN(suffix='cfg.bDisableAfterMove' )
    exec_post_init: RD[CN] = CN(suffix='cfg.bExecUserPostInit' )
    exec_post_move: RD[CN] = CN(suffix='cfg.bExecUserPostMove' )
    exec_pre_init: RD[CN] = CN(suffix='cfg.bExecUserPreInit' )
    exec_pre_move: RD[CN] = CN(suffix='cfg.bExecUserPreMove' )
    init_seq10_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[10].nAction', parser='UaInt32')
    init_seq10_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[10].lrValue1' )
    init_seq10_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[10].lrValue2' )
    init_seq1_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[1].nAction', parser='UaInt32')
    init_seq1_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[1].lrValue1' )
    init_seq1_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[1].lrValue2' )
    init_seq2_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[2].nAction', parser='UaInt32')
    init_seq2_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[2].lrValue1' )
    init_seq2_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[2].lrValue2' )
    init_seq3_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[3].nAction', parser='UaInt32')
    init_seq3_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[3].lrValue1' )
    init_seq3_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[3].lrValue2' )
    init_seq4_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[4].nAction', parser='UaInt32')
    init_seq4_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[4].lrValue1' )
    init_seq4_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[4].lrValue2' )
    init_seq5_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[5].nAction', parser='UaInt32')
    init_seq5_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[5].lrValue1' )
    init_seq5_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[5].lrValue2' )
    init_seq6_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[6].nAction', parser='UaInt32')
    init_seq6_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[6].lrValue1' )
    init_seq6_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[6].lrValue2' )
    init_seq7_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[7].nAction', parser='UaInt32')
    init_seq7_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[7].lrValue1' )
    init_seq7_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[7].lrValue2' )
    init_seq8_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[8].nAction', parser='UaInt32')
    init_seq8_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[8].lrValue1' )
    init_seq8_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[8].lrValue2' )
    init_seq9_action: RD[CN] = CN(suffix='cfg.strArrInitSeq[9].nAction', parser='UaInt32')
    init_seq9_value1: RD[CN] = CN(suffix='cfg.strArrInitSeq[9].lrValue1' )
    init_seq9_value2: RD[CN] = CN(suffix='cfg.strArrInitSeq[9].lrValue2' )
    lock: RD[CN] = CN(suffix='cfg.bLock' )
    lock_pos: RD[CN] = CN(suffix='cfg.lrLockPos' )
    lock_tolerance: RD[CN] = CN(suffix='cfg.lrLockTol' )
    low_brake: RD[CN] = CN(suffix='cfg.bActiveLowBrake' )
    low_inpos: RD[CN] = CN(suffix='cfg.bActiveLowInPos' )
    max_pos: RD[CN] = CN(suffix='cfg.lrMaxPosition' )
    min_pos: RD[CN] = CN(suffix='cfg.lrMinPosition' )
    tout_init: RD[CN] = CN(suffix='cfg.nTimeoutInit', parser='UaInt32')
    tout_move: RD[CN] = CN(suffix='cfg.nTimeoutMove', parser='UaInt32')
    tout_switch: RD[CN] = CN(suffix='cfg.nTimeoutSwitch', parser='UaInt32')
    velocity: RD[CN] = CN(suffix='cfg.lrDefaultVelocity' )



class MotorCfgData(EltDevice.Cfg.Data):
    active_low_index: NodeVar[bool] = False
    active_low_lhw: NodeVar[bool] = False
    active_low_lstop: NodeVar[bool] = False
    active_low_ref: NodeVar[bool] = False
    active_low_uhw: NodeVar[bool] = False
    active_low_ustop: NodeVar[bool] = False
    axis_type: NodeVar[int] = 0
    backlash: NodeVar[float] = 0.0
    brake: NodeVar[bool] = False
    check_inpos: NodeVar[bool] = False
    disable: NodeVar[bool] = False
    exec_post_init: NodeVar[bool] = False
    exec_post_move: NodeVar[bool] = False
    exec_pre_init: NodeVar[bool] = False
    exec_pre_move: NodeVar[bool] = False
    init_seq10_action: NodeVar[int] = 0
    init_seq10_value1: NodeVar[float] = 0.0
    init_seq10_value2: NodeVar[float] = 0.0
    init_seq1_action: NodeVar[int] = 0
    init_seq1_value1: NodeVar[float] = 0.0
    init_seq1_value2: NodeVar[float] = 0.0
    init_seq2_action: NodeVar[int] = 0
    init_seq2_value1: NodeVar[float] = 0.0
    init_seq2_value2: NodeVar[float] = 0.0
    init_seq3_action: NodeVar[int] = 0
    init_seq3_value1: NodeVar[float] = 0.0
    init_seq3_value2: NodeVar[float] = 0.0
    init_seq4_action: NodeVar[int] = 0
    init_seq4_value1: NodeVar[float] = 0.0
    init_seq4_value2: NodeVar[float] = 0.0
    init_seq5_action: NodeVar[int] = 0
    init_seq5_value1: NodeVar[float] = 0.0
    init_seq5_value2: NodeVar[float] = 0.0
    init_seq6_action: NodeVar[int] = 0
    init_seq6_value1: NodeVar[float] = 0.0
    init_seq6_value2: NodeVar[float] = 0.0
    init_seq7_action: NodeVar[int] = 0
    init_seq7_value1: NodeVar[float] = 0.0
    init_seq7_value2: NodeVar[float] = 0.0
    init_seq8_action: NodeVar[int] = 0
    init_seq8_value1: NodeVar[float] = 0.0
    init_seq8_value2: NodeVar[float] = 0.0
    init_seq9_action: NodeVar[int] = 0
    init_seq9_value1: NodeVar[float] = 0.0
    init_seq9_value2: NodeVar[float] = 0.0
    lock: NodeVar[bool] = False
    lock_pos: NodeVar[float] = 0.0
    lock_tolerance: NodeVar[float] = 0.0
    low_brake: NodeVar[bool] = False
    low_inpos: NodeVar[bool] = False
    max_pos: NodeVar[float] = 0.0
    min_pos: NodeVar[float] = 0.0
    tout_init: NodeVar[int] = 0
    tout_move: NodeVar[int] = 0
    tout_switch: NodeVar[int] = 0
    velocity: NodeVar[float] = 0.0


class MotorCfg(EltDevice.Cfg):
    Config = MotorCfgConfig
    Data = MotorCfgData
    active_low_index = N.prop('active_low_index')
    active_low_lhw = N.prop('active_low_lhw')
    active_low_lstop = N.prop('active_low_lstop')
    active_low_ref = N.prop('active_low_ref')
    active_low_uhw = N.prop('active_low_uhw')
    active_low_ustop = N.prop('active_low_ustop')
    axis_type = N.prop('axis_type')
    backlash = N.prop('backlash')
    brake = N.prop('brake')
    check_inpos = N.prop('check_inpos')
    disable = N.prop('disable')
    exec_post_init = N.prop('exec_post_init')
    exec_post_move = N.prop('exec_post_move')
    exec_pre_init = N.prop('exec_pre_init')
    exec_pre_move = N.prop('exec_pre_move')
    init_seq10_action = N.prop('init_seq10_action')
    init_seq10_value1 = N.prop('init_seq10_value1')
    init_seq10_value2 = N.prop('init_seq10_value2')
    init_seq1_action = N.prop('init_seq1_action')
    init_seq1_value1 = N.prop('init_seq1_value1')
    init_seq1_value2 = N.prop('init_seq1_value2')
    init_seq2_action = N.prop('init_seq2_action')
    init_seq2_value1 = N.prop('init_seq2_value1')
    init_seq2_value2 = N.prop('init_seq2_value2')
    init_seq3_action = N.prop('init_seq3_action')
    init_seq3_value1 = N.prop('init_seq3_value1')
    init_seq3_value2 = N.prop('init_seq3_value2')
    init_seq4_action = N.prop('init_seq4_action')
    init_seq4_value1 = N.prop('init_seq4_value1')
    init_seq4_value2 = N.prop('init_seq4_value2')
    init_seq5_action = N.prop('init_seq5_action')
    init_seq5_value1 = N.prop('init_seq5_value1')
    init_seq5_value2 = N.prop('init_seq5_value2')
    init_seq6_action = N.prop('init_seq6_action')
    init_seq6_value1 = N.prop('init_seq6_value1')
    init_seq6_value2 = N.prop('init_seq6_value2')
    init_seq7_action = N.prop('init_seq7_action')
    init_seq7_value1 = N.prop('init_seq7_value1')
    init_seq7_value2 = N.prop('init_seq7_value2')
    init_seq8_action = N.prop('init_seq8_action')
    init_seq8_value1 = N.prop('init_seq8_value1')
    init_seq8_value2 = N.prop('init_seq8_value2')
    init_seq9_action = N.prop('init_seq9_action')
    init_seq9_value1 = N.prop('init_seq9_value1')
    init_seq9_value2 = N.prop('init_seq9_value2')
    lock = N.prop('lock')
    lock_pos = N.prop('lock_pos')
    lock_tolerance = N.prop('lock_tolerance')
    low_brake = N.prop('low_brake')
    low_inpos = N.prop('low_inpos')
    max_pos = N.prop('max_pos')
    min_pos = N.prop('min_pos')
    tout_init = N.prop('tout_init')
    tout_move = N.prop('tout_move')
    tout_switch = N.prop('tout_switch')
    velocity = N.prop('velocity')



class MotorRpcsConfig(EltDevice.Rpcs.Config):
    rpcDisable: RD[CR] = CR(suffix= 'RPC_Disable')
    rpcEnable: RD[CR] = CR(suffix= 'RPC_Enable')
    rpcInit: RD[CR] = CR(suffix= 'RPC_Init')
    rpcMoveAbs: RD[CR] = CR(suffix= 'RPC_MoveAbs', arg_parsers=['Float', 'Float'] )
    rpcMoveRel: RD[CR] = CR(suffix= 'RPC_MoveRel', arg_parsers=['Float', 'Float'] )
    rpcMoveVel: RD[CR] = CR(suffix= 'RPC_MoveVel', arg_parsers=['Float'] )
    rpcReset: RD[CR] = CR(suffix= 'RPC_Reset')
    rpcStop: RD[CR] = CR(suffix= 'RPC_Stop')



class MotorRpcsData(EltDevice.Rpcs.Data):
    pass


class MotorRpcs(EltDevice.Rpcs):
    Config = MotorRpcsConfig
    Data = MotorRpcsData



class MotorStatConfig(EltDevice.Stat.Config):
    axis_brake: RD[CN] = CN(suffix='stat.bBrakeActive' )
    axis_enable: RD[CN] = CN(suffix='stat.bEnabled' )
    axis_info_data1: RD[CN] = CN(suffix='stat.nInfoData1' )
    axis_info_data2: RD[CN] = CN(suffix='stat.nInfoData2' )
    axis_inposition: RD[CN] = CN(suffix='stat.bInPosition' )
    axis_lock: RD[CN] = CN(suffix='stat.bLock' )
    axis_ready: RD[CN] = CN(suffix='stat.bAxisReady' )
    backlash_step: RD[CN] = CN(suffix='stat.nBacklashStep' )
    error_code: RD[CN] = CN(suffix='stat.nErrorCode' )
    init_action: RD[CN] = CN(suffix='stat.nInitAction' )
    init_step: RD[CN] = CN(suffix='stat.nInitStep' )
    initialised: RD[CN] = CN(suffix='stat.bInitialised' )
    local: RD[CN] = CN(suffix='stat.bLocal' )
    mode: RD[CN] = CN(suffix='stat.nMode' )
    pos_actual: RD[CN] = CN(suffix='stat.lrPosActual' )
    pos_error: RD[CN] = CN(suffix='stat.lrPosError' )
    pos_target: RD[CN] = CN(suffix='stat.lrPosTarget' )
    scale_factor: RD[CN] = CN(suffix='stat.lrScaleFactor' )
    signal_index: RD[CN] = CN(suffix='stat.signals[3].bActive' )
    signal_lhw: RD[CN] = CN(suffix='stat.signals[1].bActive' )
    signal_lstop: RD[CN] = CN(suffix='stat.signals[0].bActive' )
    signal_ref: RD[CN] = CN(suffix='stat.signals[2].bActive' )
    signal_uhw: RD[CN] = CN(suffix='stat.signals[4].bActive' )
    signal_ustop: RD[CN] = CN(suffix='stat.signals[5].bActive' )
    state: RD[CN] = CN(suffix='stat.nState' )
    status: RD[CN] = CN(suffix='stat.nStatus' )
    substate: RD[CN] = CN(suffix='stat.nSubstate' )
    vel_actual: RD[CN] = CN(suffix='stat.lrVelActual' )



class MotorStatData(EltDevice.Stat.Data):
    axis_brake: NodeVar[bool] = False
    axis_enable: NodeVar[bool] = False
    axis_info_data1: NodeVar[int] = 0
    axis_info_data2: NodeVar[int] = 0
    axis_inposition: NodeVar[bool] = False
    axis_lock: NodeVar[bool] = False
    axis_ready: NodeVar[bool] = False
    backlash_step: NodeVar[int] = 0
    error_code: NodeVar[int] = 0
    init_action: NodeVar[int] = 0
    init_step: NodeVar[int] = 0
    initialised: NodeVar[bool] = False
    local: NodeVar[bool] = False
    mode: NodeVar[int] = 0
    pos_actual: NodeVar[float] = 0.0
    pos_error: NodeVar[float] = 0.0
    pos_target: NodeVar[float] = 0.0
    scale_factor: NodeVar[float] = 0.0
    signal_index: NodeVar[bool] = False
    signal_lhw: NodeVar[bool] = False
    signal_lstop: NodeVar[bool] = False
    signal_ref: NodeVar[bool] = False
    signal_uhw: NodeVar[bool] = False
    signal_ustop: NodeVar[bool] = False
    state: NodeVar[int] = 0
    status: NodeVar[int] = 0
    substate: NodeVar[int] = 0
    vel_actual: NodeVar[float] = 0.0


class MotorStat(EltDevice.Stat):
    Config = MotorStatConfig
    Data = MotorStatData
    axis_brake = N.prop('axis_brake')
    axis_enable = N.prop('axis_enable')
    axis_info_data1 = N.prop('axis_info_data1')
    axis_info_data2 = N.prop('axis_info_data2')
    axis_inposition = N.prop('axis_inposition')
    axis_lock = N.prop('axis_lock')
    axis_ready = N.prop('axis_ready')
    backlash_step = N.prop('backlash_step')
    error_code = N.prop('error_code')
    init_action = N.prop('init_action')
    init_step = N.prop('init_step')
    initialised = N.prop('initialised')
    local = N.prop('local')
    mode = N.prop('mode')
    pos_actual = N.prop('pos_actual')
    pos_error = N.prop('pos_error')
    pos_target = N.prop('pos_target')
    scale_factor = N.prop('scale_factor')
    signal_index = N.prop('signal_index')
    signal_lhw = N.prop('signal_lhw')
    signal_lstop = N.prop('signal_lstop')
    signal_ref = N.prop('signal_ref')
    signal_uhw = N.prop('signal_uhw')
    signal_ustop = N.prop('signal_ustop')
    state = N.prop('state')
    status = N.prop('status')
    substate = N.prop('substate')
    vel_actual = N.prop('vel_actual')



class MotorConfig(EltDevice.Config):
    Cfg = MotorCfgConfig 
    Rpcs = MotorRpcsConfig 
    Stat = MotorStatConfig 
    type = 'Motor'
    cfg : RD[Cfg] = Cfg() 
    rpcs : RD[Rpcs] = Rpcs() 
    stat : RD[Stat] = Stat() 


class MotorData(EltDevice.Data):
    Cfg = MotorCfgData 
    Rpcs = MotorRpcsData 
    Stat = MotorStatData 
    cfg : Cfg = Cfg() 
    rpcs : Rpcs = Rpcs() 
    stat : Stat = Stat() 


class _Motor(EltDevice):
    Cfg = MotorCfg 
    Rpcs = MotorRpcs 
    Stat = MotorStat 
    Config = MotorConfig


    cfg = Cfg.prop('cfg')
    rpcs = Rpcs.prop('rpcs')
    stat = Stat.prop('stat')
